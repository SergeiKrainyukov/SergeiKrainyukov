<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Сергей Крайнюков. Android Developer.</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
<header>
    <h1>Сергей Крайнюков. Android Developer.</h1>
</header>

<nav>
    <ul>
        <li><a href="#">Главная</a></li>
        <li><a href="https://github.com/SergeiKrainyukov/My-Learning-Tracker/tree/main">Github</a></li>
        <li><a href="https://t.me/skrainyukov_blog">Telegram</a></li>
    </ul>
</nav>

<main>

    <article>
        <h2>Навигация в Android-приложении. Часть 4. Создаем Navigation Graph.</h2>

    </article>


    <article>
        <h2>Навигация в Android-приложении. Часть 3. Начало работы с Navigation Component.</h2>
        В этом уроке мы рассмотрим, как настроить и работать с Android Navigation Component.
        Android Navigation Component требует Android Studio 3.3 или выше и Java 8+.
        <br>
        <br>
        Для добавления поддержки навигации в ваш проект включите следующие зависимости в файл build.gradle вашего
        приложения:
        <img src="images/nav_dependencies.png" alt="">
        <h3>Создайте Navigation graph</h3>
        Навигация происходит между destinations в вашем приложении, то есть между любыми частями приложения, к
        которым пользователи могут переходить. Эти места назначения связаны между собой с помощью actions.
        <br>
        <br>
        Граф навигации - это файл ресурсов, который содержит все ваши места назначения и действия. Граф представляет
        все пути навигации в вашем приложении.
        <br>
        <br>
        На рисунке 1 показано визуальное представление графа навигации для примерного приложения, содержащего шесть
        мест назначения, связанных пятью действиями. Каждое место назначения представлено миниатюрой
        предварительного просмотра, а связывающие действия представлены стрелками, показывающими, как пользователи
        могут переходить от одного места назначения к другому.
        <br>
        <br>
        <img src="images/nav_destinations.png" alt="">
        <br>
        <br>
        1 - Места назначения представляют различные области контента в вашем приложении.
        <br>
        2 - Действия - это логические связи между вашими местами назначения, которые представляют пути, по которым могут
        перемещаться пользователи.
        <br>
        <br>
        Чтобы добавить граф навигации в ваш проект, выполните следующие действия:
        <br>
        <br>
        1) В окне "Проект" щелкните правой кнопкой мыши на директории "res" и выберите "New" > "Android Resource File".
        Появится диалоговое окно "New Resource File".
        <br>
        2) В поле "File name" введите имя, например "nav_graph".
        <br>
        3) В раскрывающемся списке "Resource type" выберите "Navigation", затем нажмите "OK".
        <br>
        <br>
        При добавлении первого графа навигации Android Studio создает директорию ресурсов навигации внутри директории
        "res". Эта директория содержит файл ресурса графа навигации (например, "nav_graph.xml").

        <h3>Navigation Editor</h3>
        После добавления графа, Android Studio открывает его в редакторе навигации (Navigation Editor). В редакторе
        навигации вы можете визуально редактировать графы навигации или непосредственно редактировать соответствующий
        XML-код.
        <br>
        <br>
        <img src="images/nav-editor-2x.png" alt="">
        <br>
        <br>
        1 - Панель "Места назначения" (Destinations panel): Показывает ваш хост навигации и все места назначения,
        которые в данный момент находятся в редакторе графа.
        <br>
        2 - Редактор графа (Graph Editor): Содержит визуальное представление вашего графа навигации. Вы можете
        переключаться между режимом "Дизайн" (Design) и подлежащим XML-представлением в режиме "Текст" (Text).
        <br>
        3 - Атрибуты (Attributes): Показывает атрибуты для текущего выбранного элемента в графе навигации.
        <br>
        <br>
        Щелкните вкладку "Текст" (Text), чтобы увидеть соответствующий XML-код, который должен выглядеть примерно
        следующим образом:
        <br>
        <br>
        <img src="images/nav_graph_code.png" alt="">
        <br>
        <br>
        Элемент navigation является корневым элементом графа навигации. При добавлении мест назначения и связывающих
        действий в граф, вы можете видеть соответствующие элементы destination и action как дочерние элементы здесь.
        Если у вас есть вложенные графы, они отображаются в виде дочерних элементов navigation.

        <h3>Добавление NavHost в активность</h3>

        Один из основных компонентов Navigation - это Navigation host. Navigation host представляет собой пустой
        контейнер, в котором места назначения заменяются при навигации пользователя по вашему приложению.
        <br>
        <br>
        Navigation host должен реализовываться от NavHost. Реализация NavHost по умолчанию в Navigation -
        NavHostFragment, который обрабатывает замену фрагментов-мест назначения.
        <br>
        <br>
        Примечание: Компонент Navigation предназначен для приложений, в которых есть одна главная активность с
        несколькими фрагментами-местами назначения. Главная активность связана с графом навигации и содержит
        NavHostFragment, который отвечает за замену мест назначения по мере необходимости. В приложении с несколькими
        активностями-местами назначения каждая активность имеет свой собственный граф навигации.
        <h3>Добавление NavHostFragment через XML</h3>
        Приведенный ниже XML-пример показывает использование NavHostFragment в основной активности приложения:
        <img src="images/nav_host.png" alt="">
        <br>
        <br>
        Обратите внимание на следующее:
        <ul>
            <li>Атрибут android:name содержит имя класса вашей реализации NavHost.
            </li>
            <li>Атрибут app:navGraph связывает NavHostFragment с графом навигации. Граф навигации определяет все места
                назначения в этом NavHostFragment, к которым пользователи могут переходить.
            </li>
            <li>Атрибут app:defaultNavHost="true" гарантирует, что ваш NavHostFragment перехватывает системную кнопку
                "Назад". Обратите внимание, что может быть только один NavHost по умолчанию. Если у вас есть несколько
                хостов в одном макете (например, макеты с двумя панелями), убедитесь, что указан только один NavHost по
                умолчанию.
            </li>
        </ul>

        <h3>Добавление места назначения в граф навигации</h3>

        Вы можете создать место назначения из существующего фрагмента или активности. Вы также можете использовать
        редактор навигации для создания нового места назначения или создания заполнителя, который затем можно заменить
        фрагментом или активностью.
        <br>
        <br>
        В этом примере давайте создадим новое место назначения. Чтобы добавить новое место назначения с помощью
        редактора навигации, выполните следующие действия:
        <br>
        <br>
        В редакторе навигации щелкните значок Создать новое место назначения , а затем выберите Создать новое место
        назначения.
        В открывшемся диалоговом окне Создание нового компонента Android создайте свой фрагмент. Дополнительную
        информацию о фрагментах см. в документации по фрагментам.
        Вернитесь в редактор навигации и обратите внимание, что Android Studio добавил это место назначения в граф.
        <br>
        <br>
        На рисунке 3 показан пример места назначения и заполнителя.
        <br>
        <br>
        <img src="images/destination_placeholder.png" alt="">
        <br>
        Рисунок 3. destination и placeholder

        <h3>Анатомия destination</h3>
        Для выбранного места назначения обратите внимание на следующие атрибуты в панели атрибутов:
        <br>
        <br>
        Поле "Type" указывает, реализовано ли место назначения в виде фрагмента, активности или другого
        пользовательского класса в вашем исходном коде.
        <br>
        Поле "Label" содержит читаемое пользователем имя места назначения. Это может быть отображено в пользовательском
        интерфейсе, например, если вы связываете NavGraph с панелью инструментов, используя метод
        setupWithNavController(). Поэтому рекомендуется использовать ресурсные строки для этого значения.
        <br>
        Поле "ID" содержит идентификатор места назначения, который используется для ссылки на место назначения в коде.
        <br>
        В выпадающем списке "Class" отображается имя класса, связанного с местом назначения. Вы можете нажать на этот
        выпадающий список, чтобы изменить связанный класс на другой тип места назначения.
        <br>
        Щелкните вкладку "Text", чтобы отобразить XML-представление вашего графа навигации. XML содержит те же атрибуты
        id, name, label и layout для места назначения, как показано ниже:
        <br>
        <img src="images/destination_xml.png" alt="">

        <h3>Назначение начального экрана</h3>

        Начальный экран - это первый экран, который пользователи видят при открытии вашего приложения, и последний
        экран, который они видят при выходе из приложения. В редакторе навигации значок домика используется для
        обозначения начального экрана.
        <br>
        <br>
        Как только у вас есть все ваши экраны (дестинации), вы можете выбрать начальный экран, выполнив следующие
        действия:
        <br>
        <br>
        В режиме "Дизайн" щелкните на экране, который вы хотите установить в качестве начального. Он будет выделен.
        <br>
        <br>
        Нажмите кнопку "Назначить начальную дестинацию". Кнопка представлена значком домика на панели инструментов
        редактора навигации. Кроме того, вы можете щелкнуть правой кнопкой мыши на экране и выбрать "Установить как
        начальную дестинацию" в контекстном меню.
        <br>
        <br>
        После назначения начальной дестинации рядом с выбранным экраном в редакторе графа появится значок домика,
        указывающий, что это начальный экран вашего приложения.
        <br>
        <br>
        Помните, что начальный экран - это первый экран, который пользователи видят при открытии приложения, и он также
        является экраном, на который они возвращаются, нажимая системную кнопку "Назад" с любого другого экрана вашего
        приложения."

        <h3>Соединение дестинаций</h3>

        Действие (action) представляет собой логическую связь между дестинациями. Действия представлены в графе
        навигации в виде стрелок. Действия обычно соединяют одну дестинацию с другой, но вы также можете создавать
        глобальные действия, которые позволяют перейти к определенной дестинации из любой части вашего приложения.
        <br>
        <br>
        С помощью действий вы представляете различные пути, которые пользователи могут пройти через ваше приложение.
        Однако, чтобы фактически перейти к дестинациям, вам все равно необходимо написать код для осуществления
        навигации. Это будет рассмотрено в разделе "Переход к дестинации" позже в данном руководстве.
        <br>
        <br>
        Вы можете использовать редактор навигации, чтобы соединить две дестинации, выполнив следующие действия:
        <br>
        <br>
        Вкладка "Дизайн", наведите курсор на правую сторону дестинации, от которой вы хотите, чтобы пользователи
        перешли. Появится круг на правой стороне дестинации, как показано на рисунке 4.
        <br>
        <img src="images/destination_hover_over.png" alt="">
        <br>
        Рисунок 4. Дестинация с кругом соединения
        <br>
        <br>
        Щелкните и удерживайте кнопку мыши, перетащите курсор на дестинацию, к которой вы хотите, чтобы пользователи
        перешли, и отпустите кнопку мыши. Линия между двумя дестинациями представляет собой действие, как показано на
        рисунке 5.
        <br>
        <img src="images/connect_destinations.png" alt="">
        <br>
        Рисунок 5. Соединение дестинаций с помощью действия
        <br>
        <br>
        Щелкните на стрелке, чтобы выделить действие. В атрибутах отображаются следующие значения:
        <br>
        <img src="images/destination_values.png" alt="">
        <br>
        <br>
        Поле "Type" содержит "Action".
        <br>
        <br>
        Поле "ID" содержит идентификатор для действия.
        <br>
        <br>
        Поле "Destination" содержит идентификатор фрагмента или активности, которую представляет дестинация.
        <br>
        <br>
        Переключитесь на вкладку "Text", чтобы перейти к XML-представлению. Теперь в исходной дестинации появляется
        элемент "action". Действие имеет свой идентификатор и атрибут "destination", содержащий идентификатор следующей
        дестинации, как показано в примере ниже:
        <br>
        <br>
        В вашем графе навигации действия представлены элементами action. Как минимум, действие содержит свой собственный
        идентификатор (ID) и идентификатор (ID) дестинации, к которой пользователь должен быть перенаправлен.
        Для перехода к конкретной дестинации используется NavController, объект, который управляет навигацией внутри
        NavHost. Каждый NavHost имеет свой собственный NavController. Вы можете получить NavController с помощью одного
        из следующих методов:
        <br>
        <br>
        Kotlin:
        <br>
        <br>
        Fragment.findNavController()
        <br>
        View.findNavController()
        <br>
        Activity.findNavController(viewId: Int)
        <br>
        <br>
        При создании NavHostFragment с использованием FragmentContainerView или при добавлении NavHostFragment в вашу
        активность с помощью FragmentTransaction, попытка получения NavController в методе onCreate() активности с
        помощью Navigation.findNavController(Activity, @IdRes int) приведет к ошибке. Вместо этого вы должны получить
        NavController напрямую из NavHostFragment.
        <br>
        <img src="images/get_nav_controller.png" alt="">
        <br>
        <br>
        <h3>Безопасность типов с использованием Safe Args</h3>
        Для обеспечения безопасности типов при переходе между дестинациями рекомендуется использовать плагин Safe Args
        для Gradle. Этот плагин генерирует простые классы объектов и строителей, которые обеспечивают безопасную
        навигацию и передачу аргументов между дестинациями.
        <br>
        <br>
        Примечание: Для других способов навигации см. Раздел Navigate to a destination.
        <br>
        Чтобы добавить Safe Args в ваш проект, включите следующий класспэт в файл build.gradle верхнего уровня:
        <br>
        <img src="images/navigation_classpath.png" alt="">
        <br>
        Вы также должны применить один из двух доступных плагинов.
        <br>
        <br>
        Для генерации кода на языке Java, подходящего для модулей на языке Java или смешанных модулей Java и Kotlin,
        добавьте следующую строку в файл build.gradle вашего приложения или модуля:
        <br>
        <img src="images/safe_args_java_kotlin.png" alt="">
        <br>
        Кроме того, для генерации кода на языке Kotlin, подходящего только для модулей на языке Kotlin, добавьте:
        <br>
        <img src="images/safe_args_kotlin_only.png" alt="">
        <br>
        Вам нужно добавить `android.useAndroidX=true` в файл `gradle.properties`, как указано в руководстве по
        переходу к AndroidX.
        <br>
        <br>
        После включения Safe Args плагин генерирует код, который содержит классы и методы для каждого определенного
        действия. Для каждого действия Safe Args также генерирует класс для каждого исходного пункта назначения, откуда
        исходит действие. Сгенерированное имя класса является комбинацией имени класса исходного пункта назначения и
        слова "Directions". Например, если пункт назначения называется SpecifyAmountFragment, то сгенерированный класс
        будет называться SpecifyAmountFragmentDirections. Сгенерированный класс содержит статический метод для каждого
        определенного действия в исходном пункте назначения. Этот метод принимает любые определенные параметры действия
        в качестве аргументов и возвращает объект NavDirections, который можно передать в метод navigate().
        <br>
        <br>
        В качестве примера предположим, что у нас есть навигационная графика с одним действием, которое соединяет
        исходный пункт назначения SpecifyAmountFragment с получающим пунктом назначения ConfirmationFragment.
        <br>
        <br>
        Safe Args генерирует класс SpecifyAmountFragmentDirections с одним методом
        actionSpecifyAmountFragmentToConfirmationFragment(), который возвращает объект NavDirections. Этот возвращаемый
        объект NavDirections может быть передан непосредственно в метод navigate(), как показано в следующем примере:
        <br>
        <img src="images/nav_directions.png" alt="">
        <br>
    </article>

    <article>
        <h2>Навигация в Android-приложении. Часть 2. Navigation Component.</h2>
        Навигация - взаимодействия, которые позволяют пользователям перемещаться между различными частями контента
        внутри вашего приложения, а также возвращаться из них. Android Jetpack Navigation Component помогает вам
        реализовать навигацию, начиная от простых нажатий кнопок до более сложных шаблонов, таких как панель приложения
        и выдвижная навигационная панель. Компонент навигации также обеспечивает последовательный и предсказуемый
        пользовательский опыт, придерживаясь установленного набора принципов.
        <br>
        <br>
        Navigation Component состоит из трех ключевых частей, которые описаны ниже:
        <ul>
            <li>Граф навигации: XML-ресурс, который содержит всю связанную с навигацией информацию в одном
                централизованном месте. Он включает все отдельные области контента в вашем приложении, называемые
                местами назначения, а также возможные пути, которые пользователь может пройти в вашем приложении.
            </li>
            <li>NavHost: Пустой контейнер, который отображает места назначения из вашего графа навигации. Navigation
                Component содержит реализацию NavHost по умолчанию - NavHostFragment, который отображает фрагменты в
                качестве мест назначения.
            </li>
            <li>NavController: Объект, который управляет навигацией внутри NavHost. NavController управляет
                переключением содержимого мест назначения в NavHost при перемещении пользователей по вашему приложению.
                При навигации в вашем приложении вы сообщаете NavController, что хотите переместиться либо по
                определенному пути в графе навигации, либо непосредственно к определенному месту назначения. Затем
                NavController отображает соответствующее место назначения в NavHost.
            </li>
        </ul>
        Navigation Component предоставляет ряд других преимуществ, включая следующие:
        <ul>
            <li>
                Управление транзакциями фрагментов.
            </li>
            <li>
                Корректная обработка действий "Вверх" и "Назад" по умолчанию.
            </li>
            <li>
                Стандартизированные ресурсы для анимаций и переходов.
            </li>
            <li>
                Реализация и обработка глубокой ссылки.
            </li>
            <li>
                Включение шаблонов пользовательского интерфейса навигации, таких как выдвижные панели навигации и нижняя
                навигация, с минимальными дополнительными настройками.
            </li>
            <li>
                Safe Args - плагин Gradle, который обеспечивает безопасность типов при навигации и передаче данных между
                местами
                назначения.
            </li>
            <li>
                Поддержка ViewModel - вы можете ограничить область видимости ViewModel для графа навигации, чтобы
                обмениваться
                данными, связанными с пользовательским интерфейсом, между местами назначения графа.
            </li>
            Кроме того, вы можете использовать редактор навигации в Android Studio версии 3.3 или выше для просмотра и
            редактирования ваших
            графов навигации.
        </ul>
        <h4>02.07.2023</h4>
    </article>

    <article>
        <h2>Навигация в Android-приложении. Часть 1. Принципы навигации в Android-приложении.</h2>
        <h4>1.Фиксированный StartDestination</h4>
        У каждого приложения, которое вы создаете, есть фиксированное начальное место назначения(StartDestination). Это
        первый экран, который пользователь видит при запуске вашего приложения из лончера. Это место назначения также
        является последним экраном, который пользователь видит при возвращении в лончер после нажатия кнопки "Назад".
        Также приложение может иметь одноразовую настройку или серию экранов входа в систему. Эти условные экраны не
        должны рассматриваться как начальные места назначения, поскольку пользователи видят эти экраны только в
        определенных случаях.
        <br>
        <br>
        <h4>2.Состояние навигации представляется в виде стека destinations.</h4>
        Когда ваше приложение запускается впервые, создается новый task для пользователя, и приложение отображает свое
        начальное место назначения. Это становится базовым местом назначения, известным как стек возврата, и является
        основой для состояния навигации вашего приложения. Верхним элементом стека является текущий экран, а предыдущие
        места назначения в стеке представляют историю, где вы уже побывали. Внизу стека всегда находится начальное место
        назначения приложения.
        <br>
        <br>
        Операции, которые изменяют стек возврата, всегда выполняются с верхним элементом стека, либо добавляя новое
        место назначения на вершину стека, либо удаляя верхний элемент из стека. Переход на место назначения добавляет
        это место назначения на вершину стека.
        <br>
        <br>
        Navigation component управляет всем порядком элементов в стеке возврата за вас, хотя вы также можете управлять
        стеком возврата самостоятельно.
        <h4>3.Кнопки "Вверх"(Up/Pop button) и "Назад"(System Back button) идентичны в рамках task вашего
            приложения.</h4>
        Кнопка "Назад" появляется в навигационной панели системы внизу экрана и используется для навигации в обратном
        хронологическом порядке через историю экранов, с которыми пользователь недавно работал. Когда вы нажимаете
        кнопку "Назад", текущее место назначения удаляется из верхней части стека возврата, и затем вы переходите к
        предыдущему месту назначения.
        <br>
        <br>
        Кнопка "Вверх" появляется в панели приложения вверху экрана. В рамках task вашего приложения кнопки "Вверх" и
        "Назад" должны вести себя идентично.
        <br>
        <br>
        <h4>4.Кнопка "Вверх" никогда не выходит из вашего приложения.</h4>
        Если пользователь находится на начальном экране вашего приложения, то кнопка "Вверх" не отображается, потому что
        кнопка "Вверх" никогда не выходит из приложения. Однако кнопка "Назад" отображается и выполняет выход из
        приложения.
        <br>
        <br>
        Когда ваше приложение запускается с использованием deeplink из другого приложения, кнопка "Вверх" переносит
        пользователей обратно в task вашего приложения через моделирование стека возврата, а не к приложению, вызвавшему
        глубокую ссылку. Однако кнопка "Назад" действительно возвращает вас к другому приложению.
        <h4>5.Глубокая ссылка (deep linking) имитирует ручную навигацию.</h4>
        Будь то глубокая ссылка или ручное перемещение к конкретному месту назначения, вы можете использовать кнопку
        "Вверх" для навигации через места назначения обратно к начальному месту назначения.
        <br>
        <br>
        При глубокой ссылке на место назначения в рамках задачи вашего приложения, любой существующий стек возврата для
        задачи вашего приложения удаляется и заменяется глубоко связанным стеком возврата.
        <br>
        <br>
        Компонент навигации поддерживает глубокие ссылки и автоматически создает реалистичный стек возврата для вас при
        переходе на любое место назначения в вашем графе навигации.
        <h4>25.06.2023</h4>
    </article>

    <article>
        <h2>Промежуточные итоги работы по технике "Форсаж" за прошедшую неделю</h2>
        <ul>
            <li>Количество невыполненных задач в день сократилось с 3-5 до 0-2</li>
            <li>Повысилось качество планирования - ставлю такие задачи и в таком объеме, который совершенно точно смогу
                выполнить
            </li>
            <li>Сложные задачи, требующие неопределенного количества времени и ресурсов, декомпозирую на более мелкие и
                формулирую таким образом, чтобы было однозначно ясно, что нужно делать и каков результат успешного
                выполнения
            </li>
        </ul>
        В целом, повысилась мотивация и появилось больше времени на качественный отдых, распорядок дня стал более
        сбалансированным.<p>
        Понял, что на меня отлично работают дедлайны по времени. Буду пользоваться данной техникой, чтобы выполнять
        задачи в правильном приоритете, не отвлекаясь на что-то лишнее.
        <p>
            Также данный способ должен быть эффективен для формирования правильных привычек, поэтому планирую с помощью
            него развить в себе пунктуальность, так как с ней у меня проблемы. Результаты будут в одном из следующих
            отчетов.
        <p>
        <h4>04.06.2023</h4>
    </article>

    <article>
        <h2>Стратегическая цель</h2>
        <p>
            Стратегическая цель на текущий момент - стать ведущим разработчиком Андроид-приложений в компании АЛИДИ.
        <p>
            Действия, которые я предпринимаю для достижения цели:
        <p>
        <ul>
            <li>Развиваю свой блог</li>
            <li>Берусь за сложные задачи и стараюсь выполнить их безупречно</li>
            <li>Разрабатываю инициативы для улучшения работы команды</li>
            <li>Прохожу курсы по программированию для повышения своего скилла</li>
            <li>Помогаю другим разработчикам в решении их задач</li>
        </ul>
        <h4>28.05.2023</h4>
    </article>

    <article>
        <h2>Работа по технике "Форсаж"</h2>
        <p>
            С сегодняшнего дня буду организовывать свою жизнь в соответствии с техникой "Форсаж", которая предполагает
            постановку задач с конкретным указанием выигрыша и проигрыша.
        <p>
            Пример постановки задачи:
        <p>
            Выложить пост в блог в воскресенье с 10:00 до 13:00.
        <p>
            Выполнение задачи - отдых и проведение времени с семьей весь оставшийся день.
        <p>
            Невыполнение задачи - перевод 500 руб. в благотворительный фонд.
        <p>
            Подобным образом буду планировать каждую свою задачу.
        <p>
        <h4>21.05.2023</h4>
    </article>

    <article>
        <h2>ТОП-3 вопроса с собеседований по Jetpack Compose</h2>
        <p>
        <h3>
            1. Что такое Jetpack Compose и в чем его преимущества?
        </h3>
        Jetpack Compose — это современный набор инструментов для создания пользовательского интерфейса Android с
        использованием Kotlin.<br><br>
        К его преимуществам относятся:
        <ul>
            <li>Независимость от конкретных релизов платформы. Все фичи, багфиксы и улучшения доступны одновременно для
                всех версий Android. Например, если в тулките появится новая UI-фича, ее можно использовать и на Android
                12, и на Android 11 — интерфейс будет выглядеть нативно на обеих версиях.
            </li>
            <li>Kotlin-only. Вся работа с UI происходит в одном Kotlin-файле, никаких xml</li>
            <li>Композитный подход: Наследованию – нет, композиции – да. Каждый UI-компонент представляет собой обычную
                composable-функцию, отвечающую за ограниченный функционал,
                никакой лишней логики как у View.java на 30 тысяч строк кода.
            </li>
            <li>
                Обратная совместимость: Для использования Compose не требуется начинать проект с нуля. Имеется
                возможность как его встраивания (с помощью ComposeView) в имеющуюся xml-вёрстку, так и наоборот.
            </li>
            <li>
                Кроссплатформенность: Изначально Jetpack Compose создавался для написания нативного UI в приложениях на
                Android. Но тулкит полюбился разработчикам и развивается в сторону кроссплатформенной разработки
                параллельно с Kotlin Multiplatform.
            </li>
            <li>
                Декларативный UI - когда вместо того, чтобы манипулировать интерфейсом, вы описываете, каким он должен
                быть.
            </li>
        </ul>

        <p>
        <h3>
            2. Из чего состоит пользовательский интерфейс Jetpack Compose?
        </h3>
        Пользовательский интерфейс состоит из Composable функций, описывающих внешний вид любого компонента UI.

        <p>
        <h3>
            3. Что такое State в Jetpack Compose?
        </h3>
        State в Jetpack Compose — это значение, которое может меняться с течением времени и запускать перерисовку
        пользовательского интерфейса при его изменении.
    </article>

    <article>
        <h2>Как был создан этот блог</h2>
        1. На главной странице во вкладке "Repositories" кликаем на кнопку "New". Создаем новый репозиторий, делаем его
        публичными ставим галочку на "Add Readme".<br>
        Файл Readme нужен для того, чтобы в дальнейшем сделать профиль на github более привлекательным для других
        пользователей и работодателей.<br>
        <img src="images/create_repo.png" alt="">
        <br>
        2. Далее открываем созданный репозиторий, идем во вкладку Add file -> create new file. Открывается новое окно
        для создания и редактирования файла. Называем файл именем<br>
        "index.html" и создаем начальную разметку. После создания разметки нажимаем "Commit changes", делаем коммит в
        main и возвращаемся на главную страницу репозитория.<br>

        <img src="images/create_index_html.png" alt="">
        <br>

        3. Добавим нашему проекту файл со стилями. По тому же алгоритму создаем новый файл, но теперь уже в названии
        вводим "css/". Благодаря данному действию у нас будет создана новая папка, в которой мы будем хранить<br>
        стили нашего блога. В этом же месте создаем файл с названием "style.css" и пишем код для задания шрифтов и тп.
        Коммитим в main по тому же алгоритму.<br>
        <img src="images/create_index_html.png" alt="">
        <br>

        4. Далее идем в Settings -> Pages, во вкладке source выбираем "Deploy from a branch" и выбираем ветку, из
        которой github создаст в итоге страницу нашего блога.<br>
        В нашем случае это ветка main. Нажимаем Save.
        <br>
        <img src="images/release_blog.png" alt="">
        <br>
        5. Обновляем страницу и видим ссылку на наш блог.
        <br>
        <img src="images/url_blog.png" alt="">
        <br>
        6. Вот и все! Наш блог создан. Это был самый простой способ создания безо всяких дополнительных IDE. Конечно,
        дальнейшее редактирование лучше выполнять в специальных средах<br>
        разработки.<br>
        <br>
        <img src="images/open_url_blog.png" alt="">
        <br>
    </article>
    <article>
        <h2>О себе</h2>
        <p>Всем привет! Я Android-разработчик, активно изучаю мобильную разработку с 2019 года. Этот блог будет посвящен
            интересным и полезным инструментам и технологиям для разработчиков. </p>
    </article>
</main>

<footer>
    <p>Copyright © 2023 Сергей Крайнюков. Android Developer.
</footer>
</body>
</html>
