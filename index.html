<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Сергей Крайнюков. Android Developer.</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
<header>
    <h1>Сергей Крайнюков. Android Developer.</h1>
</header>

<nav>
    <ul>
        <li><a href="#">Главная</a></li>
        <li><a href="https://github.com/SergeiKrainyukov/My-Learning-Tracker/tree/main">Github</a></li>
        <li><a href="https://t.me/skrainyukov_blog">Telegram</a></li>
    </ul>
</nav>

<main>

    <article>
        <h2>Навигация в Android-приложении. Часть 1. Принципы навигации в Android-приложении</h2>
        <h4>1.Фиксированный StartDestination</h4>
        У каждого приложения, которое вы создаете, есть фиксированное начальное место назначения(StartDestination). Это
        первый экран, который пользователь видит при запуске вашего приложения из лончера. Это место назначения также
        является последним экраном, который пользователь видит при возвращении в лончер после нажатия кнопки "Назад".
        Также приложение может иметь одноразовую настройку или серию экранов входа в систему. Эти условные экраны не
        должны рассматриваться как начальные места назначения, поскольку пользователи видят эти экраны только в
        определенных случаях.
        <br>
        <br>
        <h4>2.Состояние навигации представляется в виде стека destinations.</h4>
        Когда ваше приложение запускается впервые, создается новый task для пользователя, и приложение отображает свое
        начальное место назначения. Это становится базовым местом назначения, известным как стек возврата, и является
        основой для состояния навигации вашего приложения. Верхним элементом стека является текущий экран, а предыдущие
        места назначения в стеке представляют историю, где вы уже побывали. Внизу стека всегда находится начальное место
        назначения приложения.
        <br>
        <br>
        Операции, которые изменяют стек возврата, всегда выполняются с верхним элементом стека, либо добавляя новое
        место назначения на вершину стека, либо удаляя верхний элемент из стека. Переход на место назначения добавляет
        это место назначения на вершину стека.
        <br>
        <br>
        Navigation component управляет всем порядком элементов в стеке возврата за вас, хотя вы также можете управлять
        стеком возврата самостоятельно.
        <h4>3.Кнопки "Вверх"(Up/Pop button) и "Назад"(System Back button) идентичны в рамках task вашего
            приложения.</h4>
        Кнопка "Назад" появляется в навигационной панели системы внизу экрана и используется для навигации в обратном
        хронологическом порядке через историю экранов, с которыми пользователь недавно работал. Когда вы нажимаете
        кнопку "Назад", текущее место назначения удаляется из верхней части стека возврата, и затем вы переходите к
        предыдущему месту назначения.
        <br>
        <br>
        Кнопка "Вверх" появляется в панели приложения вверху экрана. В рамках task вашего приложения кнопки "Вверх" и
        "Назад" должны вести себя идентично.
        <br>
        <br>
        <h4>4.Кнопка "Вверх" никогда не выходит из вашего приложения.</h4>
        Если пользователь находится на начальном экране вашего приложения, то кнопка "Вверх" не отображается, потому что
        кнопка "Вверх" никогда не выходит из приложения. Однако кнопка "Назад" отображается и выполняет выход из
        приложения.
        <br>
        <br>
        Когда ваше приложение запускается с использованием deeplink из другого приложения, кнопка "Вверх" переносит
        пользователей обратно в task вашего приложения через моделирование стека возврата, а не к приложению, вызвавшему
        глубокую ссылку. Однако кнопка "Назад" действительно возвращает вас к другому приложению.
        <h4>5.Глубокая ссылка (deep linking) имитирует ручную навигацию.</h4>
        Будь то глубокая ссылка или ручное перемещение к конкретному месту назначения, вы можете использовать кнопку
        "Вверх" для навигации через места назначения обратно к начальному месту назначения.
        <br>
        <br>
        При глубокой ссылке на место назначения в рамках задачи вашего приложения, любой существующий стек возврата для
        задачи вашего приложения удаляется и заменяется глубоко связанным стеком возврата.
        <br>
        <br>
        Компонент навигации поддерживает глубокие ссылки и автоматически создает реалистичный стек возврата для вас при
        переходе на любое место назначения в вашем графе навигации.
        <h4>25.06.2023</h4>
    </article>

    <article>
        <h2>Промежуточные итоги работы по технике "Форсаж" за прошедшую неделю</h2>
        <ul>
            <li>Количество невыполненных задач в день сократилось с 3-5 до 0-2</li>
            <li>Повысилось качество планирования - ставлю такие задачи и в таком объеме, который совершенно точно смогу
                выполнить
            </li>
            <li>Сложные задачи, требующие неопределенного количества времени и ресурсов, декомпозирую на более мелкие и
                формулирую таким образом, чтобы было однозначно ясно, что нужно делать и каков результат успешного
                выполнения
            </li>
        </ul>
        В целом, повысилась мотивация и появилось больше времени на качественный отдых, распорядок дня стал более
        сбалансированным.<p>
        Понял, что на меня отлично работают дедлайны по времени. Буду пользоваться данной техникой, чтобы выполнять
        задачи в правильном приоритете, не отвлекаясь на что-то лишнее.
        <p>
            Также данный способ должен быть эффективен для формирования правильных привычек, поэтому планирую с помощью
            него развить в себе пунктуальность, так как с ней у меня проблемы. Результаты будут в одном из следующих
            отчетов.
        <p>
        <h4>04.06.2023</h4>
    </article>

    <article>
        <h2>Стратегическая цель</h2>
        <p>
            Стратегическая цель на текущий момент - стать ведущим разработчиком Андроид-приложений в компании АЛИДИ.
        <p>
            Действия, которые я предпринимаю для достижения цели:
        <p>
        <ul>
            <li>Развиваю свой блог</li>
            <li>Берусь за сложные задачи и стараюсь выполнить их безупречно</li>
            <li>Разрабатываю инициативы для улучшения работы команды</li>
            <li>Прохожу курсы по программированию для повышения своего скилла</li>
            <li>Помогаю другим разработчикам в решении их задач</li>
        </ul>
        <h4>28.05.2023</h4>
    </article>

    <article>
        <h2>Работа по технике "Форсаж"</h2>
        <p>
            С сегодняшнего дня буду организовывать свою жизнь в соответствии с техникой "Форсаж", которая предполагает
            постановку задач с конкретным указанием выигрыша и проигрыша.
        <p>
            Пример постановки задачи:
        <p>
            Выложить пост в блог в воскресенье с 10:00 до 13:00.
        <p>
            Выполнение задачи - отдых и проведение времени с семьей весь оставшийся день.
        <p>
            Невыполнение задачи - перевод 500 руб. в благотворительный фонд.
        <p>
            Подобным образом буду планировать каждую свою задачу.
        <p>
        <h4>21.05.2023</h4>
    </article>

    <article>
        <h2>ТОП-3 вопроса с собеседований по Jetpack Compose</h2>
        <p>
        <h3>
            1. Что такое Jetpack Compose и в чем его преимущества?
        </h3>
        Jetpack Compose — это современный набор инструментов для создания пользовательского интерфейса Android с
        использованием Kotlin.<br><br>
        К его преимуществам относятся:
        <ul>
            <li>Независимость от конкретных релизов платформы. Все фичи, багфиксы и улучшения доступны одновременно для
                всех версий Android. Например, если в тулките появится новая UI-фича, ее можно использовать и на Android
                12, и на Android 11 — интерфейс будет выглядеть нативно на обеих версиях.
            </li>
            <li>Kotlin-only. Вся работа с UI происходит в одном Kotlin-файле, никаких xml</li>
            <li>Композитный подход: Наследованию – нет, композиции – да. Каждый UI-компонент представляет собой обычную
                composable-функцию, отвечающую за ограниченный функционал,
                никакой лишней логики как у View.java на 30 тысяч строк кода.
            </li>
            <li>
                Обратная совместимость: Для использования Compose не требуется начинать проект с нуля. Имеется
                возможность как его встраивания (с помощью ComposeView) в имеющуюся xml-вёрстку, так и наоборот.
            </li>
            <li>
                Кроссплатформенность: Изначально Jetpack Compose создавался для написания нативного UI в приложениях на
                Android. Но тулкит полюбился разработчикам и развивается в сторону кроссплатформенной разработки
                параллельно с Kotlin Multiplatform.
            </li>
            <li>
                Декларативный UI - когда вместо того, чтобы манипулировать интерфейсом, вы описываете, каким он должен
                быть.
            </li>
        </ul>

        <p>
        <h3>
            2. Из чего состоит пользовательский интерфейс Jetpack Compose?
        </h3>
        Пользовательский интерфейс состоит из Composable функций, описывающих внешний вид любого компонента UI.

        <p>
        <h3>
            3. Что такое State в Jetpack Compose?
        </h3>
        State в Jetpack Compose — это значение, которое может меняться с течением времени и запускать перерисовку
        пользовательского интерфейса при его изменении.
    </article>

    <article>
        <h2>Как был создан этот блог</h2>
        1. На главной странице во вкладке "Repositories" кликаем на кнопку "New". Создаем новый репозиторий, делаем его
        публичными ставим галочку на "Add Readme".<br>
        Файл Readme нужен для того, чтобы в дальнейшем сделать профиль на github более привлекательным для других
        пользователей и работодателей.<br>
        <img src="images/create_repo.png" alt="">
        <br>
        2. Далее открываем созданный репозиторий, идем во вкладку Add file -> create new file. Открывается новое окно
        для создания и редактирования файла. Называем файл именем<br>
        "index.html" и создаем начальную разметку. После создания разметки нажимаем "Commit changes", делаем коммит в
        main и возвращаемся на главную страницу репозитория.<br>

        <img src="images/create_index_html.png" alt="">
        <br>

        3. Добавим нашему проекту файл со стилями. По тому же алгоритму создаем новый файл, но теперь уже в названии
        вводим "css/". Благодаря данному действию у нас будет создана новая папка, в которой мы будем хранить<br>
        стили нашего блога. В этом же месте создаем файл с названием "style.css" и пишем код для задания шрифтов и тп.
        Коммитим в main по тому же алгоритму.<br>
        <img src="images/create_index_html.png" alt="">
        <br>

        4. Далее идем в Settings -> Pages, во вкладке source выбираем "Deploy from a branch" и выбираем ветку, из
        которой github создаст в итоге страницу нашего блога.<br>
        В нашем случае это ветка main. Нажимаем Save.
        <br>
        <img src="images/release_blog.png" alt="">
        <br>
        5. Обновляем страницу и видим ссылку на наш блог.
        <br>
        <img src="images/url_blog.png" alt="">
        <br>
        6. Вот и все! Наш блог создан. Это был самый простой способ создания безо всяких дополнительных IDE. Конечно,
        дальнейшее редактирование лучше выполнять в специальных средах<br>
        разработки.<br>
        <br>
        <img src="images/open_url_blog.png" alt="">
        <br>
    </article>
    <article>
        <h2>О себе</h2>
        <p>Всем привет! Я Android-разработчик, активно изучаю мобильную разработку с 2019 года. Этот блог будет посвящен
            интересным и полезным инструментам и технологиям для разработчиков. </p>
    </article>
</main>

<footer>
    <p>Copyright © 2023 Сергей Крайнюков. Android Developer.
</footer>
</body>
</html>
